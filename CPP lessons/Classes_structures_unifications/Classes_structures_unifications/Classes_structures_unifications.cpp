// Classes_structures_unifications.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"


// Классы, структуры и объединения в языке С++

// Единственное отличие между структурой и классом является то, что в классе все члены по
// умолчанию закрыты, а в стркутуре открыты

/*
	struct <имя_тега> {
	// Открытые функции-члены и данные-члены
	private:
	// Закрытые функции-члены и данные-члены

	} Список объектов
*/

// В С++ struct и class создают новые типы данных

// private - сообщает компилятору, чт следующие за ним члены являются закрытыми для этого класса

// Объединения и классы здесть так же близки!

//  Объединения позваоляют создавать общие типы данных, в которых все данные используют общую память
//	Этого нельзя добиться, исопльзуя классы

// ПРИМЕР: Короткая программа, использующая struct для создания класса:


#include <iostream>
#include <string.h>

using namespace std;

// Использование структыря для определения типа класса:
struct st_type {					// Структура
	st_type(double b,char *n);		// Все, что не ptivate, то открыто
	void show();
private:							// Закрытые поля структуры
	double balance;
	char name[32];
};

st_type::st_type(double b, char *n) {
	balance = b;
	strcpy(name,n);
}


void st_type::show() {
	cout << " Имя:"<< name;
	cout << ":$" << balance;
	if (balance < 0.0) cout << "***";
	cout << "\n";
}

// Перепишем то же самое, но с использованием класса:
clsss sl_type{
	double balance;
	char name[40];
public:
	sl_type(double b, char*n);
	void show();
};

int main()
{

	//	==== Пример с использоавнием структуры, вместо класса	====
	st_type			acc1(100.12, "Johnson");
	st_type			acc2(-12.34, "Hedricks");

	acc1.show();
	acc2.show();

	// ==== То же самое, но с использованием класса		====

    return 0;
}

